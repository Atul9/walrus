//! Intermediate representation for expressions.
//!
//! The goal is to match wasm instructions as closely as possible, but translate
//! the stack machine into an expression tree. Additionally all control frames
//! are representd as `Block`s.

pub mod matcher;

use crate::dot::Dot;
use crate::ty::ValType;
use id_arena::Id;
use std::io::{self, Write};
use walrus_derive::walrus_expr;

/// The id of a local.
pub type LocalId = Id<Local>;

/// A local variable or parameter.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct Local {
    id: LocalId,
    ty: ValType,
}

impl Local {
    /// Construct a new local from the given id and type.
    pub fn new(id: LocalId, ty: ValType) -> Local {
        Local { id, ty }
    }

    /// Get this local's id that is unique across the whole module.
    pub fn id(&self) -> LocalId {
        self.id
    }

    /// Get this local's type.
    pub fn ty(&self) -> ValType {
        self.ty
    }
}

/// An identifier for a particular expression.
pub type ExprId = Id<Expr>;

impl Dot for ExprId {
    fn dot(&self, out: &mut Write) -> io::Result<()> {
        write!(out, "expr_{}", self.index())
    }
}

/// A trait for anything that is an AST node in our IR.
///
/// Implementations of this trait are generated by `#[walrus_expr]`.
pub trait Ast: Into<Expr> {
    /// The identifier type for this AST node.
    type Id: Into<ExprId>;

    /// Create a new identifier given an `ExprId` that references an `Expr` of
    /// this type.
    fn new_id(id: ExprId) -> Self::Id;
}

/// Different kinds of blocks.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum BlockKind {
    /// A `block` block.
    Block,

    /// A `loop` block.
    Loop,

    /// An `if` or `else` block.
    IfElse,

    /// The entry to a function.
    FunctionEntry,
}

/// An enum of all the different kinds of wasm expressions.
///
/// Note that the `#[walrus_expr]` macro rewrites this enum's variants from
///
/// ```ignore
/// enum Expr {
///     Variant { field: Ty, .. },
///     ...
/// }
/// ```
///
/// into
///
/// ```ignore
/// enum Expr {
///     Variant(Variant),
///     ...
/// }
///
/// struct Variant {
///     field: Ty,
///     ...
/// }
/// ```
#[walrus_expr]
#[derive(Clone, Debug)]
pub enum Expr {
    /// A block of multiple expressions, and also a control frame.
    Block {
        /// What kind of block is this?
        kind: BlockKind,
        /// The types of the expected values on the stack when entering this
        /// block.
        params: Box<[ValType]>,
        /// The types of the resulting values added to the stack after this
        /// block is evaluated.
        results: Box<[ValType]>,
        /// The expressions that make up the body of this block.
        exprs: Vec<ExprId>,
    },

    /// `get_local n`
    GetLocal {
        /// The type of this local.
        ty: ValType,
        /// The local being got.
        local: LocalId,
    },

    /// `set_local n`
    SetLocal {
        /// The type of this local.
        ty: ValType,
        /// The local being set.
        local: LocalId,
        /// The value to set the local to.
        value: ExprId,
    },

    /// `i32.const`
    I32Const {
        /// The constant value.
        value: i32,
    },

    /// `i32.add`
    I32Add {
        /// The left-hand operand.
        lhs: ExprId,
        /// The right-hand operand.
        rhs: ExprId,
    },

    /// `i32.sub`
    I32Sub {
        /// The left-hand operand.
        lhs: ExprId,
        /// The right-hand operand.
        rhs: ExprId,
    },

    /// `i32.mul`
    I32Mul {
        /// The left-hand operand.
        lhs: ExprId,
        /// The right-hand operand.
        rhs: ExprId,
    },

    /// `i32.eqz`
    I32Eqz {
        /// The operand to test if it is equal to zero.
        expr: ExprId,
    },

    /// `i32.popcnt`
    I32Popcnt {
        /// The operand whose bits should be counted.
        expr: ExprId,
    },

    /// `select`
    Select {
        /// The condition.
        condition: ExprId,
        /// The value returned when the condition is true. Evaluated regardless
        /// if the condition is true.
        consequent: ExprId,
        /// The value returned when the condition is false. Evaluated regardless
        /// if the condition is false.
        alternative: ExprId,
    },

    /// `unreachable`
    Unreachable {},

    /// `br`
    Br {
        /// The target block to branch to.
        block: BlockId,
        /// The arguments to the block.
        args: Box<[ExprId]>,
    },

    /// `br_if`
    BrIf {
        /// The condition for when to branch.
        condition: ExprId,
        /// The target block to branch to when the condition is met.
        block: BlockId,
        /// The arguments to the block.
        args: Box<[ExprId]>,
    },

    /// `if ... else ... end`
    IfElse {
        /// The condition.
        condition: ExprId,
        /// The block to execute when the condition is true.
        consequent: BlockId,
        /// The block to execute when the condition is false.
        alternative: BlockId,
    },

    /// `br_table`
    BrTable {
        /// The table index of which block to branch to.
        which: ExprId,
        /// The table of target blocks.
        blocks: Box<[BlockId]>,
        /// The block that is branched to by default when `which` is out of the
        /// table's bounds.
        default: BlockId,
        /// The arguments to the block.
        args: Box<[ExprId]>,
    },

    /// `drop`
    Drop {
        /// The expression to be evaluated and results ignored.
        expr: ExprId,
    },

    /// `return`
    Return {
        /// The values being returned.
        values: Box<[ExprId]>,
    },
}

impl Expr {
    /// Are any instructions that follow this expression's instruction (within
    /// the current block) unreachable?
    ///
    /// Returns `true` for unconditional branches (`br`, `return`, etc...) and
    /// `unreachable`. Returns `false` for all other "normal" instructions
    /// (`i32.add`, etc...).
    pub fn following_instructions_are_unreachable(&self) -> bool {
        match *self {
            Expr::Unreachable(..) | Expr::Br(..) | Expr::BrTable(..) | Expr::Return(..) => true,

            // No `_` arm to make sure that we properly update this function as
            // we add support for new instructions.
            Expr::Block(..)
            | Expr::GetLocal(..)
            | Expr::SetLocal(..)
            | Expr::I32Const(..)
            | Expr::I32Add(..)
            | Expr::I32Sub(..)
            | Expr::I32Mul(..)
            | Expr::I32Eqz(..)
            | Expr::I32Popcnt(..)
            | Expr::Select(..)
            | Expr::BrIf(..)
            | Expr::IfElse(..)
            | Expr::Drop(..) => false,
        }
    }
}

impl Block {
    /// Construct a new block.
    pub fn new(kind: BlockKind, params: Box<[ValType]>, results: Box<[ValType]>) -> Block {
        let exprs = vec![];
        Block {
            kind,
            params,
            results,
            exprs,
        }
    }
}
